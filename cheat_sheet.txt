ヒストリー展開:

プロセス展開:
<(list)		listプロセスの実行による標準出力を標準入力にリダイレクト
=(list)		listプロセスの実行による標準出力を書き込んだ一時ファイルの名前に展開され
                コマンドの引きするとして渡す。一時ファイルはコマンドが終了した時点で削除される
=(<<<arg)	argを展開した値が here-string として一時ファイルに書き込まれコマンドの引数として渡す
                ex. cat =(<<<"foo bar")
                    バックグラウンド処理する場合にはサブシェルを使うこと ex. (mycmd =(myoutput)) &!
>(list)		標準出力をlistプロセスの標準入力にリダイレクトする
                setopt multios で複数指定でき、その場合は同じデータがそれぞれに送られる

変数展開
http://amt.ty.land.to/OpenNote/zsh.info.html#sec42

${name}		変数の値に置換
${+name}	nameがセットされたパラメータだったら 1 そうでなかったらゼロ

${name-word}	nameがセットされていれば値を返し、そうでなければwordを返す
${name:-word}	nameがセットされていて空でなければ値を返し、そうでなければwordを返す。
		nameが省略された場合は常にwordを返す。

${name=word}	nameがセットされていなければwordをセットし、結果の値を返す
${name:=word}	nameがセットされていないか空であればwordをセットする、結果の値を返す
${name::=word}	nameにワードを無条件にセットし、結果の値を返す

${name?word}	nameがセットされてれば値を返す。そうでなければwordを表示してshellをexit
${name:?word}	nameがセットされていて空でなければ値を返す。そうでなければwordを表示してshellをexit
		wordが省略された場合は標準メッセージが表示される

${name+word}	nameがセットされていればwordを返す
${name:+word}	nameがセットされていて空でなければwordを返す

${name#pattern} ${name##pattern}
    * パターンがnameの値に前方マッチしたら、マッチした部分を除いた値を返す。そうでなかったら単に値を返す
    * # の方は最短マッチ、 ## は最長マッチ
${name%pattern} ${name%%pattern}
    * パターンがnameの値に後方マッチしたら、マッチした部分を除いた値を返す。そうでなかったら単に値を返す
    * % の方は最短マッチ、 %% は最長マッチ

${name:#pattern}	パターンがnameにマッチしたら空文字列を返し、そうでなかったら値を返す

${name:|arrayname}	nameの値がスカラの場合、arrayname配列の要素に一致したら空をそうでなければ値を返す
                        nameが配列の場合、arrayname配列の要素に一致した要素を取り除いた後に通常の配列展開
                        をした結果の文字列を返す
${name:*arrayname}	上と同様だが、arrayname配列の要素と一致しなかったものが取り除かれる

   % a=(p q r) ; b=(x y r q)
   % c=(${b:|a}) => c=(x y) 
   % c=(${b:*a}) => c=(r q) 

${name:offset} ${name:offset:length}

${name/pattern/repl} ${name//pattern/repl}
    * nameのパターンにマッチする部分が repl に置き換えられる
    * ${name/pattern/repl} の方が、最初のマッチだけ置換
    * ${name//pattern/repl} の方が、すべてんマッチを置換
    * ダブルクォート文字列と同じ展開規則が適用されるので ${name/$opat/$npat} のように書くことができる
    * パターンに # や % をつけて、最初や最後のマッチを指定できる

${#spec}
    * spec が変数名だと値の長さ、配列だと配列長
    * ^, =, ~ を # と組み合わせる時は # より前に置く

${^spec}, ${^^spec}: RC_EXPAND_PARAM オプションを on/off する。
    ex. xx=(P Q R) ; foo${^xx}bar => fooPbar fooQbar fooRbar

${=spec}, $(==spec}: SH_WORD_SPLIT オプションを on/off する
    ex. xx="P Q R" ; (${=xx}) => (P Q R) ; (${==xx}) => ('P Q R')

${~spec}, ${~~spec}: GLOB_SUBST オプションを on/off する

  (フラグ)
  	a=64 ; ${(#)a} => '@'	# setopt multibyte で unicode も展開する
	a="%m"; ${(%)a} => 'hostname'		# %escape の展開
        "${(@)foo}" <=> "${foo[@]}"

        x=(1 ' x y ' 3) ; (${(Oa)x}) => (3 'x y' 1)	# reverse array (sort reverse w/index)
        ソートの指定は a;w/index, i;case-insesitively, n;decimal-integer, o;ascending, O;descending
        順序基準を指定しない場合は lexical&case-sensitive

        ${(q)x} # Quote
        ${(Q)x} # Unquote
        ${(L)x} # lower
        ${(U)x} # upper
        ${(t)x} # x の方を表す文字列 ex. typeset -l a; a='abc' ; ${(t)a} => 'array-lower'

        a=(1 2 3 2 3 1) ; ${(u)a} => (1 2 3)	# unique
        a="x y  z" ; ${(w)#a} => 3		# count words
        a="x y  z" ; ${(W)#a} => 4		# count words(include empty words)

        ${(z)x}		# シェルがコマンドラインを解析する方式でwordsに分割する
        ${(0)x}		# null char (\0) で分割する <==> ${(ps.\0.)x}

        foo=bar; bar=baz; ${(P)foo} <=> ${(P)${foo}} <=> ${(P)$(echo bar)} # 間接参照

	a=( P Q R ); ${(j.::.)a} => 'P::Q::R'	# join
        x="J-K-L"; (${(s.-.)x}) => (J K L)	# split

コマンド置換:
$( list )
$(<file)	cat と同じだがもっと早い

算術展開:	$[exp] または $((exp)) でexpを評価した結果に展開する

Brace展開: 複数のwordに展開する
foo{xx,yy,zz} => fooxx fooyy foozz
{1..3} => 1 2 3
{1..7..2} => 1 3 5 7
{-9..3..001} => -09 -08 -07 -06 -05 -04 -03 -02 -01 000 001 002 003
(setopt brace_ccl の場合のみ) {a-f0-9} => 0 1 2 3 4 5 6 7 8 9 a b c d e f

----------------------------------------------------------------------
短縮形
if [[ -r ~/.zshrc ]] source ~/.zshrc
for distro in Vine Gentoo Berry Momonga; echo $distro Linux
for distro ( Ubuntu Fedora SUSE Debian ) echo $distro Linux
for (( i=1 ; i < 10 ; i++ )) echo $i
i=0 ; while [[ $i -le 10 ]] { echo $((i++)) }
